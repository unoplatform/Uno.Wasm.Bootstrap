<Project>
	<PropertyGroup>
		<_UnoBootstrapTaskBinary>$(MSBuildThisFileDirectory)../tools/Uno.Wasm.Bootstrap.v0.dll</_UnoBootstrapTaskBinary>

		<_WasmShellTasksPathIsDevMode>false</_WasmShellTasksPathIsDevMode>
		<_WasmShellTasksPathIsDevMode Condition="!Exists('$(_UnoBootstrapTaskBinary)')">true</_WasmShellTasksPathIsDevMode>
		<WasmShellTasksPath Condition="$(_WasmShellTasksPathIsDevMode)">$(MSBuildThisFileDirectory)../bin/$(Configuration)/netstandard2.0</WasmShellTasksPath>
		<WasmShellTasksPath Condition="!$(_WasmShellTasksPathIsDevMode)">../tools</WasmShellTasksPath>

		<WasmShellIndexHtmlPath Condition="!Exists('$(_UnoBootstrapTaskBinary)')">$(MSBuildThisFileDirectory)../Templates/index.html</WasmShellIndexHtmlPath>
		<WasmShellIndexHtmlPath Condition="Exists('$(_UnoBootstrapTaskBinary)') and '$(WasmShellIndexHtmlPath)'==''">$(MSBuildThisFileDirectory)../tools/templates/index.html</WasmShellIndexHtmlPath>

		<WasmShellContentExtensionsToExclude Condition="'$(WasmShellContentExtensionsToExclude)' == ''">.a;.bc;.o</WasmShellContentExtensionsToExclude>

		<WasmEnableThreads Condition=" '$(WasmShellEnableThreads)' == 'true' ">true</WasmEnableThreads>

		<WasmShellMode Condition="'$(WasmShellMode)'==''">browser</WasmShellMode>

		<BlazorWebAssemblyJiterpreter Condition=" $(NETCoreSdkVersion.Contains('rc.1')) ">false</BlazorWebAssemblyJiterpreter>

		<!-- Enable fingerprinting of dotnet.js for better cache busting behavior.
		     Since we control the loading through uno-bootstrap.js, we always use the fingerprinted version. -->
		<WasmFingerprintDotnetJs>true</WasmFingerprintDotnetJs>
	</PropertyGroup>

	<!-- AOT Profiling support -->
	<PropertyGroup Condition=" '$(WasmShellGenerateAOTProfile)' == 'true' ">
		<!-- Enable AOT profiling using a single property -->
		<WasmProfilers>$(WasmProfilers);aot;</WasmProfilers>

		<!-- Make the build faster by disabling compression -->
		<DisableBuildCompression>true</DisableBuildCompression>

		<!-- Disable AOT Compilation, log profiler can't trace calls in that mode -->
		<RunAOTCompilation>false</RunAOTCompilation>

		<!-- Ensure that emcc is running so the log profiler is included -->
		<WasmBuildNative>true</WasmBuildNative>

		<!-- Trimming must not be used for the profiler support assembly to be used -->
		<PublishTrimmed>false</PublishTrimmed>

	</PropertyGroup>

	<!-- Log profiler support -->
	<PropertyGroup Condition=" '$(WasmShellEnableLogProfiler)' == 'true' ">
		<!-- Enable AOT profiling using a single property -->
		<WasmProfilers>$(WasmProfilers);log;</WasmProfilers>

		<!-- Make the build faster by disabling compression -->
		<DisableBuildCompression>true</DisableBuildCompression>

		<!-- Disable AOT Compilation, log profiler can't trace calls in that mode -->
		<RunAOTCompilation>false</RunAOTCompilation>

		<!-- Ensure that emcc is running so the log profiler is included -->
		<WasmBuildNative>true</WasmBuildNative>

		<!-- Trimming must not be used for the profiler support assembly to be used -->
		<PublishTrimmed>false</PublishTrimmed>
	</PropertyGroup>

	<PropertyGroup Condition=" '$(WasmShellMonoRuntimeExecutionMode)' == 'InterpreterAndAOT' AND '$(WasmShellGenerateAOTProfile)' != 'true' ">
		<RunAOTCompilation>true</RunAOTCompilation>
		<WasmBuildNative>true</WasmBuildNative>
	</PropertyGroup>

	<Target Name="_UnoWasmValidateCompatibleSdk"
			BeforeTargets="BeforeBuild"
			Condition=" '$(TargetFramework)' != '' AND '$(Disable_UnoWasmValidateCompatibleSdk)' != 'true' ">

		<!-- Fail the build if the TargetFramework is below 9.0 -->
		<Error Condition=" $([MSBuild]::VersionLessThan( $([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')), '9.0')) "
			   Text="This version of Uno.Wasm.Bootstrap is not compatible with $(TargetFramework). Use net10.0 or later, see https://aka.platform.uno/wasm-net9-upgrade for more details." />

	</Target>

	<Target Name="_UnoInjectAOTSupport"
			BeforeTargets="ResolveRuntimePackAssets"
			Condition=" '$(WasmShellGenerateAOTProfile)' == 'true' ">
		<ItemGroup>
			<Reference Include="Uno.Wasm.AotProfiler"
					   HintPath="$([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', '..', 'tools', 'support'))Uno.Wasm.AotProfiler.dll"
					   CopyToOutputDirectory="Always"
					   PostProcessAssembly="true" />
			<TrimmerRootAssembly Include="Uno.Wasm.AotProfiler" />
		</ItemGroup>
	</Target>

	<Target Name="_UnoInjectLogProfilerSupport"
			BeforeTargets="ResolveRuntimePackAssets"
			Condition=" '$(WasmShellEnableLogProfiler)' == 'true' ">
		<ItemGroup>
			<Reference Include="Uno.Wasm.LogProfiler"
					   HintPath="$([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', '..', 'tools', 'support'))Uno.Wasm.LogProfiler.dll"
					   CopyToOutputDirectory="Always"
					   PostProcessAssembly="true" />
			<TrimmerRootAssembly Include="Uno.Wasm.LogProfiler" />
		</ItemGroup>
	</Target>

	<Target Name="_UnoInjectHotReloadSupport"
			BeforeTargets="ResolveRuntimePackAssets"
			Condition=" '$(Optimize)' != 'true' ">
		<ItemGroup>
			<Reference Include="Uno.Wasm.MetadataUpdater"
					   HintPath="$([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', '..', 'tools', 'support'))Uno.Wasm.MetadataUpdater.dll"
					   CopyToOutputDirectory="Always"
					   PostProcessAssembly="true" />
			<TrimmerRootAssembly Include="Uno.Wasm.MetadataUpdater" />
		</ItemGroup>
	</Target>

	<Target Name="_UnoAdjustEmscriptenVersion"
			BeforeTargets="_SetupEmscripten;_WorkaroundEmscriptenPathLength">

		<PropertyGroup>
			<!-- We cannot yet use EmscriptenVersion: https://github.com/dotnet/runtime/issues/108972 -->
			<_UnoEmscriptenVersion>$([System.Text.RegularExpressions.Regex]::Match($(EmscriptenSdkToolsPath), 'Microsoft\.NET\.Runtime\.Emscripten\.(?&lt;Version>\d+(\.\d+)*)\.Sdk').Groups['Version'].Value)</_UnoEmscriptenVersion>
		</PropertyGroup>
	</Target>

	<Target Name="_WorkaroundEmscriptenPathLength"
			Condition=" '$(OS)' == 'Windows_NT' "
			BeforeTargets="_SetupEmscripten">

		<PropertyGroup>
			<_emsdkOriginalPackagePath>$([System.IO.Path]::GetFullPath('$(EmscriptenSdkToolsPath)..'))</_emsdkOriginalPackagePath>
			<_targetEMSDKPath>$(USERPROFILE)\.uno\emsdk\$([System.IO.Path]::GetFileName('$(_emsdkOriginalPackagePath)'))</_targetEMSDKPath>
		</PropertyGroup>

		<MakeDir Directories="$([System.IO.Path]::GetDirectoryName('$(_targetEMSDKPath)'))" />

		<Exec Command="mklink /J &quot;$(_targetEMSDKPath)&quot; &quot;$(EmscriptenSdkToolsPath)..\tools\&quot;"
			  ContinueOnError="true"
			  Condition="!exists($(_targetEMSDKPath))"/>

		<PropertyGroup>
			<EmscriptenSdkToolsPath>$(_targetEMSDKPath)\</EmscriptenSdkToolsPath>
			<EmscriptenUpstreamBinPath>$(EmscriptenSdkToolsPath)bin\</EmscriptenUpstreamBinPath>
			<EmscriptenUpstreamEmscriptenPath>$(EmscriptenSdkToolsPath)emscripten\</EmscriptenUpstreamEmscriptenPath>
		</PropertyGroup>

		<ItemGroup>
			<EmscriptenPrependPATH Remove="@(EmscriptenPrependPATH)" />
			<EmscriptenPrependPATH Include="$(EmscriptenUpstreamBinPath)" />
			<EmscriptenPrependPATH Include="$(EmscriptenUpstreamEmscriptenPath)" />
		</ItemGroup>

	</Target>

	<Target Name="_UnoAdjustCompatibility"
			BeforeTargets="ResolveStaticWebAssetsConfiguration">

		<ItemGroup>
			<!-- IDBFS support -->
			<WasmShellExtraEmccFlags Condition=" '$(WasmShellEnableIDBFS)' == 'true' " Include="-lidbfs.js" />
			<WasmShellEmccExportedRuntimeMethod Condition=" '$(WasmShellEnableIDBFS)' == 'true' " Include="IDBFS" />

			<!-- PInvoke compat -->
			<_WasmPInvokeModules Include="__Native" />
			<_WasmPInvokeModules Include="__Internal" />
			<_WasmPInvokeModules Include="@(WasmShellAdditionalPInvokeLibrary)" />

			<!-- emcc methods compatibility -->
			<EmccExportedRuntimeMethod Include="@(WasmShellEmccExportedRuntimeMethod)" />

			<!-- Native files compat -->
			<NativeFileReference Include="@(WasmShellNativeCompile)" />

			<_NativeAssetsFiltered Include="@(Assets)" Condition=" '%(Extension)'=='.a' OR '%(Extension)'=='.o' OR '%(Extension)'=='.bc' " />

			<TrimmerRootDescriptor Include="@(LinkerDescriptor)" />

			<_AOT_InternalForceInterpretAssemblies Include="@(MonoRuntimeMixedModeExcludedAssembly->'%(Filename).dll')" />
		</ItemGroup>

		<PropertyGroup>
			<!-- SIMD compatibility-->
			<WasmEnableSIMD Condition=" '$(WasmShellEnableSimd)' != '' ">$(WasmShellEnableSimd)</WasmEnableSIMD>

			<!-- Dedup compatibility -->
			<WasmDedup Condition=" '$(WasmShellEnableAOTDeduplication)' != '' ">$(WasmShellEnableAOTDeduplication)</WasmDedup>

			<!-- Linker performance compatibility -->
			<WasmLinkOptimizationFlag Condition=" '$(WasmShellEmccLinkOptimizationLevel)' == 'None' ">-O0</WasmLinkOptimizationFlag>
			<WasmLinkOptimizationFlag Condition=" '$(WasmShellEmccLinkOptimizationLevel)' == 'Leve1' ">-O1</WasmLinkOptimizationFlag>
			<WasmLinkOptimizationFlag Condition=" '$(WasmShellEmccLinkOptimizationLevel)' == 'Level2' ">-O2</WasmLinkOptimizationFlag>
			<WasmLinkOptimizationFlag Condition=" '$(WasmShellEmccLinkOptimizationLevel)' == 'Level3' ">-O3</WasmLinkOptimizationFlag>
			<WasmLinkOptimizationFlag Condition=" '$(WasmShellEmccLinkOptimizationLevel)' == 'Maximum' ">-Oz</WasmLinkOptimizationFlag>

			<WasmLinkOptimizationFlag Condition=" '$(WasmShellEmccLinkOptimization)' == 'false' ">-O0</WasmLinkOptimizationFlag>

			<!-- Profiled AOT Compat -->
			<WasmAotProfilePath Condition="@(WasmShellEnableAotProfile->Count()) > 0" >@(WasmShellEnableAotProfile)</WasmAotProfilePath>

			<!-- Jiterpreter compatibility -->
			<BlazorWebAssemblyJiterpreter Condition=" '$(WasmShellEnableJiterpreter)' != '' AND '$(BlazorWebAssemblyJiterpreter)' == '' ">$(WasmShellEnableJiterpreter)</BlazorWebAssemblyJiterpreter>

			<!-- EMCC flags compatibility -->
			<EmccFlags>$(EmccFlags);@(WasmShellExtraEmccFlags)</EmccFlags>

			<EmccFlags Condition=" '$(WasmShellEnableEmccProfiling)' == 'true' ">$(EmccFlags);--profiling</EmccFlags>

			<!-- Threading compatibility -->
			<WasmEnableThreads Condition=" '$(WasmShellEnableThreads)' == 'true' ">true</WasmEnableThreads>

			<!-- https://github.com/dotnet/runtime/blob/1231a9addd0fb3cfb806c2a89cb45a3018c48bb2/src/mono/browser/build/BrowserWasmApp.targets#L125-L126 -->
			<_WasmPThreadPoolInitialSize Condition=" '$(WasmShellPThreadsPoolSize)' == 'true' ">true</_WasmPThreadPoolInitialSize>

			<!-- Native build compatibility -->
			<WasmBuildNative Condition=" 
				@(WasmShellAdditionalPInvokeLibrary->Count()) > 0
				OR @(NativeFileReference->Count()) > 0
				OR @(_NativeAssetsFiltered->Count()) > 0
				OR @(EmccExportedRuntimeMethod->Count()) > 0
				OR @(WasmShellExtraEmccFlags->Count()) > 0
				">true</WasmBuildNative>

			<!-- Compatibility mode that forces trimming when a linker descriptor is provided -->
			<PublishTrimmed Condition=" '$(PublishTrimmed)' == '' AND '@(LinkerDescriptor)' != '' AND '$(WasmShellILLinkerEnabled)' != 'false' ">true</PublishTrimmed>
		</PropertyGroup>

		<!--
			Override the cache path if it's not yet been set to use project
			local folder, in order to avoid the frozen cache of the runtime's
			emsdk.
		-->
		<PropertyGroup Condition=" '$(WasmCachePath)' == '$(EmscriptenCacheSdkCacheDir)' ">

			<WasmCachePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)emsdk-cache'))</WasmCachePath>

			<!-- Adjust the cache on windows if the drive is not the same -->
			<WasmCachePath Condition="
				'$(OS)' == 'Windows_NT'
				AND '$(EmscriptenSdkToolsPath)' != ''
				AND '$(EmscriptenSdkToolsPath.Substring(1))' != '$(MSBuildProjectDirectory.Substring(1))'
				">$(TMP)\emsdk-cache</WasmCachePath>

		</PropertyGroup>

		<Warning
		  Condition="
		  	'$(registry:HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem@LongPathsEnabled)'!='1' 
			AND '$(UnoUIDisableLongPathWarning)'==''
			AND $([MSBuild]::IsOSPlatform('Windows'))
			"
		  Text="Windows LongPath support is not enabled, you may experience build errors. You can avoid these by enabling LongPath with &quot;reg ADD HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem /v LongPathsEnabled /t REG_DWORD /d 1&quot;, or disable this warning by setting UnoUIDisableLongPathWarning to true."/>

		<ItemGroup>
			<_NativeAssetsFiltered Remove="@(_NativeAssetsFiltered)" />
		</ItemGroup>
	</Target>

	<UsingTask Condition="!$(_WasmShellTasksPathIsDevMode)" AssemblyFile="$(WasmShellTasksPath)/Uno.Wasm.Bootstrap.v0.dll" TaskName="Uno.Wasm.Bootstrap.ShellTask_v0" />
	<UsingTask Condition="!$(_WasmShellTasksPathIsDevMode)" AssemblyFile="$(WasmShellTasksPath)/Uno.Wasm.Bootstrap.v0.dll" TaskName="Uno.Wasm.Bootstrap.GenerateUnoAssetsManifest_v0" />
	<UsingTask Condition="!$(_WasmShellTasksPathIsDevMode)" AssemblyFile="$(WasmShellTasksPath)/Uno.Wasm.Bootstrap.v0.dll" TaskName="Uno.Wasm.Bootstrap.StaticWebAssetsResolverTask_v0" />
	<UsingTask Condition="!$(_WasmShellTasksPathIsDevMode)" AssemblyFile="$(WasmShellTasksPath)/Uno.Wasm.Bootstrap.v0.dll" TaskName="Uno.Wasm.Bootstrap.GenerateUnoNativeAssetsTask_v0" />

	<UsingTask Condition="$(_WasmShellTasksPathIsDevMode)" AssemblyFile="$(WasmShellTasksPath)/Uno.Wasm.Bootstrap.v0.dll" TaskName="Uno.Wasm.Bootstrap.ShellTask_v0" TaskFactory="TaskHostFactory" />
	<UsingTask Condition="$(_WasmShellTasksPathIsDevMode)" AssemblyFile="$(WasmShellTasksPath)/Uno.Wasm.Bootstrap.v0.dll" TaskName="Uno.Wasm.Bootstrap.GenerateUnoAssetsManifest_v0" TaskFactory="TaskHostFactory" />
	<UsingTask Condition="$(_WasmShellTasksPathIsDevMode)" AssemblyFile="$(WasmShellTasksPath)/Uno.Wasm.Bootstrap.v0.dll" TaskName="Uno.Wasm.Bootstrap.StaticWebAssetsResolverTask_v0" TaskFactory="TaskHostFactory" />
	<UsingTask Condition="$(_WasmShellTasksPathIsDevMode)" AssemblyFile	="$(WasmShellTasksPath)/Uno.Wasm.Bootstrap.v0.dll" TaskName="Uno.Wasm.Bootstrap.GenerateUnoNativeAssetsTask_v0" TaskFactory="TaskHostFactory" />

	<PropertyGroup>
		<UnoGenerateAssetsManifestDependsOn>
			$(UnoGenerateAssetsManifestDependsOn);
			GenerateUnoWasmAssets;
		</UnoGenerateAssetsManifestDependsOn>
	</PropertyGroup>

	<Target Name="UnoGenerateAssetsManifest"
			BeforeTargets="ResolveStaticWebAssetsInputs"
			DependsOnTargets="$(UnoGenerateAssetsManifestDependsOn)">
		<GenerateUnoAssetsManifest_v0
			StaticWebAsset="@(StaticWebAsset)"
			FingerprintPatterns="@(StaticWebAssetFingerprintPattern)"
			OutputPackagePath="$(WasmShellOutputPackagePath)"
			IntermediateOutputPath="$(IntermediateOutputPath)">
			<Output TaskParameter="UnoAssetsFile" ItemName="_UnoAssetsManifest" />
		</GenerateUnoAssetsManifest_v0>

		<DefineStaticWebAssets
		  CandidateAssets="@(_UnoAssetsManifest)"
		  FingerprintCandidates="$(StaticWebAssetsFingerprintContent)"
		  FingerprintPatterns="@(StaticWebAssetFingerprintPattern)"
		  RelativePathPattern="wwwroot/**"
		  SourceType="Discovered"
		  SourceId="$(PackageId)"
		  ContentRoot="$(MSBuildProjectDirectory)\wwwroot\"
		  BasePath="$(StaticWebAssetBasePath)"
		  AssetMergeSource="$(StaticWebAssetMergeTarget)">
			<Output TaskParameter="Assets" ItemName="StaticWebAsset" />
		</DefineStaticWebAssets>

		<DefineStaticWebAssetEndpoints
			  CandidateAssets="@(StaticWebAsset)"
			  ExistingEndpoints="@(StaticWebAssetEndpoint)"
			  ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
			<Output TaskParameter="Endpoints" ItemName="StaticWebAssetEndpoint" />
		</DefineStaticWebAssetEndpoints>
	</Target>

	<Target Name="GenerateUnoWasmNativeAssets" BeforeTargets="PrepareInputsForWasmBuild">

		<GenerateUnoNativeAssetsTask_v0
			AotProfile="$(WasmAotProfilePath)"
			AOTProfileExcludedMethods="$(WasmShellAOTProfileExcludedMethods)"
			Assets="@(WasmShellNativeFileReference);@(ContentWithTargetPath);@(_UnoWasmCopyToOutputAssets)"
			CurrentProjectPath="$(MSBuildProjectDirectory)"
			EmscriptenVersion="$(_UnoEmscriptenVersion)"
			EnableThreads="@(WasmEnableThreads)"
			GenerateAOTProfile="$(WasmShellGenerateAOTProfile)"
			GenerateAOTProfileDebugList="$(WasmShellGenerateAOTProfileDebugList)"
			IntermediateOutputPath="$(IntermediateOutputPath)"
			MixedModeExcludedAssembly="@(MonoRuntimeMixedModeExcludedAssembly)"
			RunAOTCompilation="$(RunAOTCompilation)"
			WasmBuildNative="$(WasmBuildNative)"
			>
			<Output TaskParameter="NativeFileReference" ItemName="NativeFileReference" />
			<Output TaskParameter="FilteredAotProfile" PropertyName="_FilteredAotProfile" />
		</GenerateUnoNativeAssetsTask_v0>

		<PropertyGroup Condition=" '$(_FilteredAotProfile)' != '' ">
			<!-- Override the user's profile with the filtered one -->
			<WasmAotProfilePath>$([System.IO.Path]::GetFullPath($(_FilteredAotProfile)))</WasmAotProfilePath>
		</PropertyGroup>

		<PropertyGroup>

			<!-- if we found native references, let's enable wasm native build as well -->
			<WasmBuildNative Condition=" 
				$(WasmBuildNative) == ''
				AND @(NativeFileReference->Count()) > 0"
				>true</WasmBuildNative>

		</PropertyGroup>

	</Target>

	<Target Name="GenerateUnoWasmAssets"
		BeforeTargets="ResolveStaticWebAssetsInputs;ResolveJSModuleStaticWebAssets;ResolveJsInitializerModuleStaticWebAssets;_UnoWasmNativeForBuild"
		DependsOnTargets="_UnoAdjustCompatibility">

		<ItemGroup>
			<!-- Filter ReferenceCopyLocalPaths as it may contain pdbs as well -->
			<_UnoWasmBootstrapAssembliesForReferenceCopyLocalPaths
			  Include="@(ReferenceCopyLocalPaths)"
			  Condition="'%(Extension)' == '.dll'" />
		</ItemGroup>

		<ItemGroup>
			<_UnoWasmCopyToOutputAssets
				Include="@(_AllChildProjectItemsWithTargetPath)"
				Condition=" '%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)' == 'PreserveNewest' OR '%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)' == 'Always' " />

			<ContentWithTargetPath Remove="$(WasmPWAManifestFile)" />
		</ItemGroup>

		<ShellTask_v0
			AotProfile="$(WasmAotProfilePath)"
			Assembly="$(IntermediateOutputPath)$(TargetFileName)"
			AssemblyName="$(AssemblyName)"
			Assets="@(ContentWithTargetPath);@(_UnoWasmCopyToOutputAssets)"
			ContentExtensionsToExclude="$(WasmShellContentExtensionsToExclude)"
			CSPConfiguration="$(WasmShellCSPConfiguration)"
			CurrentProjectPath="$(MSBuildProjectDirectory)"
			EmbeddedResources="@(EmbeddedResource)"
			EmccExportedRuntimeMethod="@(EmccExportedRuntimeMethod)"
			EmccFlags="@(EmccFlags)"
			EnableLogProfiler="$(WasmShellEnableLogProfiler)"
			EnableThreads="@(WasmEnableThreads)"
			EnableTracing="@(WasmEnableTracing)"
			GenerateAOTProfile="$(WasmShellGenerateAOTProfile)"
			IndexHtmlPath="$(WasmShellIndexHtmlPath)"
			IntermediateOutputPath="$(IntermediateOutputPath)"
			LoadAllSatelliteResources="$(WasmShellLoadAllSatelliteResources)"
			LogProfilerOptions="$(WasmShellLogProfilerOptions)"
			MonoEnvironment="@(WasmShellMonoEnvironment)"
			PublishTrimmed="$(PublishTrimmed)"
			RunILLink="$(RunILLink)"
			RuntimeOptions="$(WasmShellRuntimeOptions)"
			PWAManifestFile="$(WasmPWAManifestFile)"
			ReferencePath="@(_UnoWasmBootstrapAssembliesForReferenceCopyLocalPaths)"
			RunAOTCompilation="$(RunAOTCompilation)"
			ExistingStaticWebAsset="@(StaticWebAsset)"
			Optimize="$(Optimize)"
			WasmBuildNative="$(WasmBuildNative)"
			WasmShellMode="$(WasmShellMode)"
			WebAppBasePath="$(WasmShellWebAppBasePath)">
			<Output TaskParameter="StaticWebContent" ItemName="_UnoStaticWebContent" />
			<Output TaskParameter="PackageAssetsFolder" PropertyName="WasmShellOutputPackagePath" />
		</ShellTask_v0>

		<DefineStaticWebAssets
		  CandidateAssets="@(_UnoStaticWebContent)"
		  FingerprintCandidates="$(StaticWebAssetsFingerprintContent)"
		  FingerprintPatterns="@(StaticWebAssetFingerprintPattern)"
		  RelativePathPattern="wwwroot/**"
		  SourceType="Discovered"
		  SourceId="$(PackageId)"
		  ContentRoot="$(MSBuildProjectDirectory)\wwwroot\"
		  BasePath="$(StaticWebAssetBasePath)"
		  AssetMergeSource="$(StaticWebAssetMergeTarget)">
			<Output TaskParameter="Assets" ItemName="StaticWebAsset" />
		</DefineStaticWebAssets>

		<DefineStaticWebAssetEndpoints
			  CandidateAssets="@(StaticWebAsset)"
			  ExistingEndpoints="@(StaticWebAssetEndpoint)"
			  ContentTypeMappings="@(StaticWebAssetContentTypeMapping)"
				>
			<Output TaskParameter="Endpoints" ItemName="StaticWebAssetEndpoint" />
		</DefineStaticWebAssetEndpoints>

	</Target>

	<!--
		Detect when we're in a publish operation to enable publish-specific logic.
		This runs early in the publish process to set up state for later targets.
	-->
	<Target Name="_UnoDetectPublishOperation"
			BeforeTargets="GetCopyToPublishDirectoryItems;ComputeFilesToPublish;ResolvePublishStaticWebAssets">

		<PropertyGroup>
			<_UnoIsPublishing Condition="'$(PublishDir)' != '' OR '$(_IsPublishing)' == 'true' OR '$(DeployOnBuild)' == 'true' OR '$(IsPublishing)' == 'true'">true</_UnoIsPublishing>
		</PropertyGroup>

		<Message Importance="high" Text="[Uno] Publish detection: _UnoIsPublishing=$(_UnoIsPublishing), PublishDir=$(PublishDir), _IsPublishing=$(_IsPublishing), IsPublishing=$(IsPublishing)" />
	</Target>

	<!--
		Update uno-config.js with the fingerprinted dotnet.js filename.
		This runs after static web assets are resolved so we have access to the Fingerprint metadata.
		We need separate targets for build and publish because the fingerprint changes during publish
		(due to AOT compilation, optimization, etc.).
	-->
	<Target Name="_UnoUpdateDotnetJsFingerprint"
			AfterTargets="ResolveStaticWebAssetsInputs">

		<!-- Find the dotnet.js StaticWebAsset and extract its fingerprint -->
		<ItemGroup>
			<_UnoDotnetJsAsset Include="@(StaticWebAsset)"
				Condition="$([System.String]::Copy('%(RelativePath)').StartsWith('_framework/dotnet#[.{fingerprint}]')) AND $([System.String]::Copy('%(RelativePath)').EndsWith('.js')) AND !$([System.String]::Copy('%(RelativePath)').Contains('.native')) AND !$([System.String]::Copy('%(RelativePath)').Contains('.runtime'))" />
		</ItemGroup>

		<PropertyGroup>
			<_UnoDotnetJsFingerprint>@(_UnoDotnetJsAsset->'%(Fingerprint)')</_UnoDotnetJsFingerprint>
			<_UnoConfigJsPath>$(IntermediateOutputPath)unowwwrootassets/uno-config.js</_UnoConfigJsPath>
		</PropertyGroup>

		<!-- Update the uno-config.js file with the fingerprinted filename if we found a fingerprint -->
		<WriteLinesToFile
			File="$(_UnoConfigJsPath)"
			Lines="$([System.IO.File]::ReadAllText('$(_UnoConfigJsPath)').Replace('config.dotnet_js_filename = &quot;dotnet.js&quot;', 'config.dotnet_js_filename = &quot;dotnet.$(_UnoDotnetJsFingerprint).js&quot;').Replace('_framework/dotnet.js', '_framework/dotnet.$(_UnoDotnetJsFingerprint).js'))"
			Overwrite="true"
			Condition="'$(_UnoDotnetJsFingerprint)' != '' AND Exists('$(_UnoConfigJsPath)')" />
	</Target>

	<!--
		Update uno-config.js with the publish-time fingerprinted dotnet.js filename.
		During publish, the dotnet.js is regenerated with different content (AOT, optimizations)
		and gets a new fingerprint, so we need to update the config again.
	-->
	<Target Name="_UnoUpdateDotnetJsFingerprintPublish"
			AfterTargets="ResolvePublishStaticWebAssets;GetCopyToPublishDirectoryItems"
			Condition="'$(_UnoIsPublishing)' == 'true' OR '$(PublishDir)' != ''">

		<Message Importance="high" Text="[Uno] _UnoUpdateDotnetJsFingerprintPublish running (_UnoIsPublishing=$(_UnoIsPublishing), PublishDir=$(PublishDir))" />

		<!-- Find the dotnet.js StaticWebAsset from publish assets and extract its fingerprint.
		     We look for assets where AssetMode is 'All' or 'Publish' to get the publish-time fingerprint.
		     During publish, the RelativePath may already be resolved to the actual fingerprinted value
		     (e.g., '_framework/dotnet.abc123.js') instead of the placeholder pattern, so we match both. -->
		<ItemGroup>
			<_UnoDotnetJsAssetPublish Include="@(StaticWebAsset)"
				Condition="($([System.String]::Copy('%(RelativePath)').StartsWith('_framework/dotnet#[.{fingerprint}]')) OR $([System.Text.RegularExpressions.Regex]::IsMatch('%(RelativePath)', '^_framework/dotnet\.[a-z0-9]+\.js$'))) AND $([System.String]::Copy('%(RelativePath)').EndsWith('.js')) AND !$([System.String]::Copy('%(RelativePath)').Contains('.native')) AND !$([System.String]::Copy('%(RelativePath)').Contains('.runtime')) AND ('%(AssetMode)' == 'All' OR '%(AssetMode)' == 'Publish' OR '%(AssetMode)' == '')" />
		</ItemGroup>

		<!-- Get the fingerprint from metadata first, then fall back to extracting from RelativePath if empty -->
		<PropertyGroup>
			<_UnoDotnetJsFingerprintPublish>%(_UnoDotnetJsAssetPublish.Fingerprint)</_UnoDotnetJsFingerprintPublish>
			<_UnoDotnetJsFingerprintPublish Condition="'$(_UnoDotnetJsFingerprintPublish)' == ''">$([System.Text.RegularExpressions.Regex]::Match('%(_UnoDotnetJsAssetPublish.RelativePath)', 'dotnet\.([a-z0-9]+)\.js$').Groups[1].Value)</_UnoDotnetJsFingerprintPublish>
			<_UnoConfigJsPath>$(IntermediateOutputPath)unowwwrootassets/uno-config.js</_UnoConfigJsPath>
		</PropertyGroup>

		<!-- Update the uno-config.js file with the publish fingerprint using regex to handle any previous fingerprint -->
		<WriteLinesToFile
			File="$(_UnoConfigJsPath)"
			Lines="$([System.Text.RegularExpressions.Regex]::Replace($([System.Text.RegularExpressions.Regex]::Replace($([System.IO.File]::ReadAllText('$(_UnoConfigJsPath)')), 'config\.dotnet_js_filename = &quot;dotnet\.[^&quot;]+\.js&quot;', 'config.dotnet_js_filename = &quot;dotnet.$(_UnoDotnetJsFingerprintPublish).js&quot;')), '_framework/dotnet\.[^&quot;]+\.js', '_framework/dotnet.$(_UnoDotnetJsFingerprintPublish).js'))"
			Overwrite="true"
			Condition="'$(_UnoDotnetJsFingerprintPublish)' != '' AND Exists('$(_UnoConfigJsPath)')" />
	</Target>

	<!--
		Final safety net: Update uno-config.js directly in the publish output directory.
		This runs AFTER files have been copied to ensure the fingerprint is always correct,
		regardless of MSBuild target ordering or caching behavior.
	-->
	<Target Name="_UnoUpdateDotnetJsFingerprintPublishOutput"
			AfterTargets="Publish;_CopyResolvedFilesToPublishAlways;_CopyResolvedFilesToPublishPreserveNewest"
			Condition="'$(WasmFingerprintDotnetJs)' == 'true' AND ('$(_UnoIsPublishing)' == 'true' OR '$(PublishDir)' != '')">

		<!-- Determine the actual publish directory location -->
		<PropertyGroup>
			<_UnoActualPublishDir Condition="'$(PublishDir)' != '' AND Exists('$(PublishDir)')">$(PublishDir)</_UnoActualPublishDir>
			<_UnoActualPublishDir Condition="'$(_UnoActualPublishDir)' == '' AND Exists('$(OutputPath)publish/')">$(OutputPath)publish/</_UnoActualPublishDir>
			<_UnoActualPublishDir Condition="'$(_UnoActualPublishDir)' == '' AND Exists('$(OutDir)publish/')">$(OutDir)publish/</_UnoActualPublishDir>
		</PropertyGroup>

		<Message Importance="high" Text="[Uno] _UnoUpdateDotnetJsFingerprintPublishOutput running" />
		<Message Importance="high" Text="[Uno] PublishDir=$(PublishDir), OutputPath=$(OutputPath), OutDir=$(OutDir)" />
		<Message Importance="high" Text="[Uno] Checking publish output directory: $(_UnoActualPublishDir)" />

		<!-- Find the actual dotnet.js file in the publish _framework directory -->
		<ItemGroup>
			<_UnoPublishedDotnetJs Include="$(_UnoActualPublishDir)wwwroot/_framework/dotnet.*.js"
				Exclude="$(_UnoActualPublishDir)wwwroot/_framework/dotnet.native.*.js;$(_UnoActualPublishDir)wwwroot/_framework/dotnet.runtime.*.js" />
		</ItemGroup>

		<!-- Extract fingerprint from actual filename -->
		<PropertyGroup>
			<_UnoActualDotnetJsFingerprint>$([System.Text.RegularExpressions.Regex]::Match('%(_UnoPublishedDotnetJs.Filename)', '^dotnet\.([a-z0-9]+)$').Groups[1].Value)</_UnoActualDotnetJsFingerprint>
			<_UnoPublishConfigJsPath Condition="'$(_UnoActualPublishDir)' != ''">$(_UnoActualPublishDir)wwwroot/$(WasmShellOutputPackagePath)/uno-config.js</_UnoPublishConfigJsPath>
			<!-- Fallback without package path -->
			<_UnoPublishConfigJsPath Condition="'$(_UnoPublishConfigJsPath)' == '' OR !Exists('$(_UnoPublishConfigJsPath)')">$(_UnoActualPublishDir)wwwroot/uno-config.js</_UnoPublishConfigJsPath>
		</PropertyGroup>

		<Message Importance="high"
				 Text="[Uno] Found dotnet.js fingerprint: $(_UnoActualDotnetJsFingerprint) at $(_UnoActualPublishDir)wwwroot/_framework/"
				 Condition="'$(_UnoActualDotnetJsFingerprint)' != ''" />

		<Message Importance="high"
				 Text="[Uno] Updating uno-config.js at: $(_UnoPublishConfigJsPath)"
				 Condition="'$(_UnoActualDotnetJsFingerprint)' != '' AND Exists('$(_UnoPublishConfigJsPath)')" />

		<Warning Text="[Uno] Could not find dotnet.js file in publish output at: $(_UnoActualPublishDir)wwwroot/_framework/"
				 Condition="'$(_UnoActualDotnetJsFingerprint)' == '' AND '$(_UnoActualPublishDir)' != ''" />

		<Warning Text="[Uno] Could not find uno-config.js at: $(_UnoPublishConfigJsPath)"
				 Condition="'$(_UnoActualDotnetJsFingerprint)' != '' AND !Exists('$(_UnoPublishConfigJsPath)')" />

		<!-- Update uno-config.js in the publish output with the actual fingerprint -->
		<WriteLinesToFile
			File="$(_UnoPublishConfigJsPath)"
			Lines="$([System.Text.RegularExpressions.Regex]::Replace($([System.Text.RegularExpressions.Regex]::Replace($([System.IO.File]::ReadAllText('$(_UnoPublishConfigJsPath)')), 'config\.dotnet_js_filename = &quot;dotnet(\.[^&quot;]+)?\.js&quot;', 'config.dotnet_js_filename = &quot;dotnet.$(_UnoActualDotnetJsFingerprint).js&quot;')), '_framework/dotnet(\.[^&quot;]+)?\.js', '_framework/dotnet.$(_UnoActualDotnetJsFingerprint).js'))"
			Overwrite="true"
			Condition="'$(_UnoActualDotnetJsFingerprint)' != '' AND Exists('$(_UnoPublishConfigJsPath)')" />

		<Message Importance="normal"
				 Text="Updated uno-config.js with dotnet.js fingerprint: $(_UnoActualDotnetJsFingerprint)"
				 Condition="'$(_UnoActualDotnetJsFingerprint)' != ''" />
	</Target>

	<!--
		Validate that uno-config.js fingerprint matches the actual dotnet.js file.
	-->
	<Target Name="_UnoValidateDotnetJsFingerprintPublish"
			AfterTargets="_UnoUpdateDotnetJsFingerprintPublishOutput"
			Condition="'$(WasmFingerprintDotnetJs)' == 'true' AND '$(UnoSkipDotnetJsFingerprintValidation)' != 'true'">

		<!-- Try multiple possible publish directory locations -->
		<PropertyGroup>
			<_UnoValidatePublishDir Condition="'$(PublishDir)' != '' AND Exists('$(PublishDir)')">$(PublishDir)</_UnoValidatePublishDir>
			<_UnoValidatePublishDir Condition="'$(_UnoValidatePublishDir)' == '' AND Exists('$(OutputPath)publish/')">$(OutputPath)publish/</_UnoValidatePublishDir>
			<_UnoValidatePublishDir Condition="'$(_UnoValidatePublishDir)' == '' AND Exists('$(OutDir)publish/')">$(OutDir)publish/</_UnoValidatePublishDir>

			<_UnoPublishConfigJsPath Condition="'$(_UnoValidatePublishDir)' != ''">$(_UnoValidatePublishDir)wwwroot/$(WasmShellOutputPackagePath)/uno-config.js</_UnoPublishConfigJsPath>
			<_UnoPublishConfigJsPath Condition="!Exists('$(_UnoPublishConfigJsPath)')">$(_UnoValidatePublishDir)wwwroot/uno-config.js</_UnoPublishConfigJsPath>
			<_UnoFrameworkPath Condition="'$(_UnoValidatePublishDir)' != ''">$(_UnoValidatePublishDir)wwwroot/_framework</_UnoFrameworkPath>
		</PropertyGroup>

		<!-- List all dotnet.*.js files for diagnostics -->
		<ItemGroup>
			<_UnoDotnetJsFilesFound Include="$(_UnoFrameworkPath)/dotnet.*.js"
				Exclude="$(_UnoFrameworkPath)/dotnet.native.*.js;$(_UnoFrameworkPath)/dotnet.runtime.*.js" />
		</ItemGroup>

		<Message Importance="low"
				 Text="[Uno] Found dotnet.js files in publish output: @(_UnoDotnetJsFilesFound)"
				 Condition="'@(_UnoDotnetJsFilesFound)' != ''" />

		<PropertyGroup Condition="Exists('$(_UnoPublishConfigJsPath)')">
			<_UnoConfigContent>$([System.IO.File]::ReadAllText('$(_UnoPublishConfigJsPath)'))</_UnoConfigContent>
			<_UnoConfigFingerprint>$([System.Text.RegularExpressions.Regex]::Match('$(_UnoConfigContent)', 'dotnet\.([a-z0-9]+)\.js').Groups[1].Value)</_UnoConfigFingerprint>
		</PropertyGroup>

		<Error Condition="'$(_UnoConfigFingerprint)' == ''"
			   Code="UNOWASM001"
			   Text="uno-config.js does not contain a fingerprinted dotnet.js reference." />

		<Error Condition="'$(_UnoConfigFingerprint)' != '' AND !Exists('$(_UnoFrameworkPath)/dotnet.$(_UnoConfigFingerprint).js')"
			   Code="UNOWASM002"
			   Text="Fingerprint mismatch: uno-config.js references dotnet.$(_UnoConfigFingerprint).js but file does not exist in $(_UnoFrameworkPath). Found: @(_UnoDotnetJsFilesFound)" />

		<Message Importance="normal"
				 Text="Validated: uno-config.js fingerprint ($(_UnoConfigFingerprint)) matches actual dotnet.js file"
				 Condition="'$(_UnoConfigFingerprint)' != ''" />
	</Target>

	<PropertyGroup>
		<UnoEnableEmccProfiling_BeforeTargets>
			$(UnoEnableEmccProfiling_BeforeTargets);
			_WasmCommonPrepareForWasmBuildNative;
		</UnoEnableEmccProfiling_BeforeTargets>
	</PropertyGroup>

	<Target Name="UnoEnableEmccProfiling"
			BeforeTargets="$(UnoEnableEmccProfiling_BeforeTargets)"
			Condition=" '$(WasmShellEnableEmccProfiling)' == 'true' ">
		<PropertyGroup>
			<!-- Enable debug symbols for release mode to profiling -->
			<WasmNativeStrip>false</WasmNativeStrip>
			<WasmNativeDebugSymbols>true</WasmNativeDebugSymbols>
		</PropertyGroup>
	</Target>

	<!-- Workaround for https://github.com/unoplatform/Uno.Wasm.Bootstrap/issues/973 -->
	<Target Name="_UnoAdjustGetCurrentProjectBuildStaticWebAssetItems"
			DependsOnTargets="GetCurrentProjectBuildStaticWebAssetItems"
			Returns="@(_CachedBuildStaticWebAssetItems)"
			Condition=" $([MSBuild]::VersionGreaterThanOrEquals('$(NETCoreSdkVersion)', '9.0.300')) and '$(UnoDisableGetCurrentProjectBuildStaticWebAssetItems)' != 'true' ">

		<ItemGroup>
			<_UnoCachedBuildStaticWebAssets Include="@(_CachedBuildStaticWebAssetItems)">
				<OriginalItemSpec Condition="'%(_CachedBuildStaticWebAssetItems.OriginalItemSpec)' != ''">$([System.IO.Path]::GetFullPath('%(_CachedBuildStaticWebAssetItems.OriginalItemSpec)'))</OriginalItemSpec>
			</_UnoCachedBuildStaticWebAssets>
			<_CachedBuildStaticWebAssetItems Remove="@(_CachedBuildStaticWebAssetItems)" />
			<_CachedBuildStaticWebAssetItems Include="@(_UnoCachedBuildStaticWebAssets)" />
		</ItemGroup>
	</Target>

	<!-- Manual detection of the workloads tooling, particularly when non-standard TFMs are used (e.g. netx.0-browserwasm) -->
	<Target Name="_UnoValidateWasmToolsWorkload"
			AfterTargets="_UnoAdjustCompatibility"
			Condition="'$(UnoSkipWasmToolsWorkloadValidation)' != 'true'">
		<PropertyGroup>
			<_UnoRequiresWasmTools>false</_UnoRequiresWasmTools>
			<_UnoRequiresWasmTools Condition="'$(WasmBuildNative)' == 'true'">true</_UnoRequiresWasmTools>
			<_UnoRequiresWasmTools Condition="'@(NativeFileReference)' != ''">true</_UnoRequiresWasmTools>
			<_UnoRequiresWasmTools Condition="'@(WasmShellNativeCompile)' != ''">true</_UnoRequiresWasmTools>
			<_UnoRequiresWasmTools Condition="'@(WasmShellAdditionalPInvokeLibrary)' != ''">true</_UnoRequiresWasmTools>
			<_UnoRequiresWasmTools Condition="'@(WasmShellExtraEmccFlags)' != ''">true</_UnoRequiresWasmTools>
			<_UnoRequiresWasmTools Condition="'@(EmccExportedRuntimeMethod)' != ''">true</_UnoRequiresWasmTools>
			<_UnoRequiresWasmTools Condition="'@(_NativeAssetsFiltered)' != ''">true</_UnoRequiresWasmTools>
		</PropertyGroup>

		<Error Code="UNOWA0001"
				Condition="'$(_UnoRequiresWasmTools)' == 'true' and '$(WasmNativeWorkloadAvailable)' != 'true'"
				Text="Native WebAssembly assets were detected, but the wasm-tools workload could not be located. Install it by running uno.check (https://aka.platform.uno/uno-check) or 'dotnet workload install wasm-tools'." />
	</Target>

</Project>
